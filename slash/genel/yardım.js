const { EmbedBuilder, Colors, ActionRowBuilder, ButtonBuilder, ButtonStyle, ComponentType } = require("discord.js");

module.exports = {
    name: "yardƒ±m",
    description: "Komutlar hakkƒ±nda yardƒ±m al.",
    options: [],
    run: async (client, interaction) => {
        const categories = {
            "Moderasyon": {
                "Kullanƒ±cƒ± Y√∂netimi": [
                    { name: "> ban", description: "\n Bir kullanƒ±cƒ±yƒ± sunucudan yasaklar." },
                    { name: "> kick", description: "\n Bir kullanƒ±cƒ±yƒ± sunucudan atar." },
                    { name: "> timeout", description: "\n Bir kullanƒ±cƒ±ya belirli bir s√ºreyle timeout uygular (susturur)." },
                    { name: "> untimeout", description: "\n Bir kullanƒ±cƒ±nƒ±n timeout'unu (susturmasƒ±nƒ±) kaldƒ±rƒ±r." },
                    { name: "> unban", description: "\n Bir kullanƒ±cƒ±nƒ±n banƒ±nƒ± (yasaƒüƒ±nƒ±) kaldƒ±rƒ±r." },
                    { name: "> snipe", description: "\n Kanalda silinen son mesajƒ± g√∂sterir." },
                    { name: "> embed", description: "\n Mesajlarƒ±nƒ±z i√ßin √∂zelle≈ütirilmi≈ü bir embed olu≈üturun **(yanlƒ±zca slash)**." }
                ],
                "Kanal Y√∂netimi": [
                    { name: "> lock/kilitle", description: "\n Kanalƒ± kilitlersin **(yanlƒ±zca prefix)**." },
                    { name: "> unlock/kilit-a√ß", description: "\n Kanalƒ±n kilidini a√ßarsƒ±n **(yanlƒ±zca prefix)**." },
                    { name: "> kilit`", description: "\n Kanalƒ±n kilidini a√ßƒ±p kapatƒ±rsƒ±n **(yanlƒ±zca slash)**." },
                    { name: "> nuke`", description: "\n Kanalƒ± silip tekrar a√ßarsƒ±n." },
                    { name: "> clear/sil", description: "\n 14 g√ºne kadar olan mesajlarƒ± silersin." }
                ],
                "√áekili≈ü": [
                    { name: "> gcr/gcreate/√ßekili≈ü", description: "\n √áekili≈ü ba≈ülatƒ±rsƒ±n. **(yanlƒ±zca prefix)**." },
                    { name: "> ginfo/√ßekilisinfo", description: "\n √áekili≈üin durumu hakkƒ±nda bilgi verir. **(yanlƒ±zca prefix)**." },
                    { name: "> gmember/katƒ±lƒ±mcƒ±lar", description: "\n √áekili≈üe katƒ±lan kullanƒ±cƒ±larƒ± g√∂sterir **(yanlƒ±zca prefix)**." },
                    { name: "> reroll/greroll", description: "\n Biten √ßekili≈üi yeniden √ßeker **(yanlƒ±zca prefix)**." }
                ]
            },
            "Kullanƒ±cƒ±": {
                "Temel Komutlar": [
                    { name: "> avatar", description: "\n Bir kullanƒ±cƒ±nƒ±n avatarƒ±nƒ± g√∂r√ºnt√ºler." },
                    { name: "> ping", description: "\n Botun gecikme s√ºresini g√∂sterir." },
                    { name: "> a≈ük√∂l√ßer", description: "\n Kullanƒ±cƒ±lar arasƒ±nda a≈ük seviyesi √∂l√ßer (Rastegele)." },
                    { name: "> afk", description: "\n AFK moduna ge√ßer ve belirttiƒüiniz sebebi g√∂sterir." },
                    { name: "> kullanƒ±cƒ±bilgi", description: "\n Kullanƒ±cƒ± hakkƒ±nda bilgi verir." },
                    { name: "> sunucubanner", description: "\n Sunucu bannerƒ±nƒ± g√∂sterir." },
                    { name: "> sunucubilgi", description: "\n Sunucu hakkƒ±nda bilgi verir." },
                    { name: "> sunucupp", description: "\n Sunucu profilini g√∂sterir." },
                    { name: "> yardƒ±m", description: "\n Komutlar hakkƒ±nda yardƒ±m saƒülar." },
                    { name: "> yaz", description: "\n Yazdƒ±ƒüƒ±nƒ±z metni yazar." },
                    { name: "> ping", description: "\n Pingi g√∂sterir." },
                    { name: "> botbilgi/istatistik/botstat", description: "\n Botun istatistiklerini g√∂sterir." },
                    { name: "> statkanallarƒ±/statschannels", description: "\n Stat Kanallarƒ±nƒ± kurarsƒ±n." }
                ],
                "Okane": [
                    { name: "> trivia", description: "\n Anime trivia oyununu oynarsƒ±n **(yanlƒ±zca prefix)**." },
                    { name: "> bj/blackjack", description: "\n Blackjack oyununu oynarsƒ±n **(yanlƒ±zca prefix)**." },
                    { name: "> daily", description: "\n G√ºnl√ºk √∂d√ºl alƒ±rsƒ±n **(yanlƒ±zca prefix)**." },
                    { name: "> okane/bal", description: "\n Kullanƒ±cƒ±nƒ±n okane (oyun parasƒ±) miktarƒ±nƒ± g√∂sterir **(yanlƒ±zca prefix)**." },
                    { name: "> rank/level", description: "\n Kullanƒ±cƒ±nƒ±n seviyesini g√∂sterir." },
                    { name: "> transfer/oktr", description: "\n Kullanƒ±cƒ±ya okane (oyun parasƒ±) transfer edersin **(yanlƒ±zca prefix)**." }
                ],
                "Eƒülence": [
                    { name: "> sayƒ±sayma ba≈ülat/durdur", description: "\n Sayƒ± sayma oyununu ba≈ülatƒ±p durdurusun." },
                    { name: "> sayƒ±tahmin ba≈ülat/durdur", description: "\n Sayƒ± tahmin oyununu ba≈ülatƒ±p durdurusun." },
                    { name: "> bom ba≈ülat/durdur", description: "\n Bom oyununu ba≈ülatƒ±p durdurusun." },
                    { name: "> adamasmaca ba≈ülat/durdur", description: "\n Bom oyununu ba≈ülatƒ±p durdurusun." },
                    { name: "> wordchain/kelimezinciri ba≈ülat/durdur", description: "\n Wordchain oyununu ba≈ülatƒ±p durdurusun." },
                ]
            },
            "Sistemler": {
                "Koruma": [
                    { name: "> koruma", description: "\n Koruma sistemlerini a√ß/kapat." },
                    { name: "> wlrole/whitelistrole", description: "\n Koruma sistemlerinden muaf tutulacak rolleri y√∂netir." }
                ],
                "Destek": [
                    { name: "> desteksistemi", description: "\n Destek sistemini a√ßmaya veye kapatmaya yarar." },
                ]
            },
            "Sunucu": [
                { name: "> otorol", description: "\n Otorol sistemini kurarsƒ±n." },
                { name: "> otorol-kapat", description: "\n Otorol sistemini kapatƒ±rsƒ±n **(yanlƒ±zca prefix)**." },
                { name: "> hg-bb", description: "\n Ho≈ügeldin Bye Bye Sistemini ayarlarsƒ±n." },
                { name: "> kurulum/setup", description: "\n Sunucuda √ße≈üitli kurulum i≈ülemlerini ger√ßekle≈ütirirsin. (Bot sahibi √∂zel)" },
                { name: "> √∂zelodasistemi", description: "\n **(prefix)** √ñzel oda sistemini a√ßar. \n **(slash)**  √ñzel oda sistemini a√ßar/kapatƒ±r." },
                { name: "> √∂zeloda kapat", description: "\n √ñzel oda sistemini kapatƒ±r **(yanlƒ±zca prefix)**." }
            ]
        };

        const homepageEmbed = new EmbedBuilder()
            .setTitle('Yardƒ±m Men√ºs√º')
            .setDescription('L√ºtfen bir kategori se√ßin:')
            .setImage('https://giffiles.alphacoders.com/219/219370.gif')
            .setColor(Colors.Blue)
            .setTimestamp();

        const homepageButtons = Object.keys(categories).map(category => 
            new ButtonBuilder()
                .setCustomId(category)
                .setLabel(category)
                .setStyle(ButtonStyle.Primary)
                .setEmoji('üìÇ')
        );

        const homepageActionRow = new ActionRowBuilder().addComponents(homepageButtons);

        const reply = await interaction.reply({ 
            embeds: [homepageEmbed], 
            components: [homepageActionRow],
            ephemeral: false
        });

        const collector = reply.createMessageComponentCollector({ 
            componentType: ComponentType.Button, 
            time: 60000 
        });

        let currentPage = 0;
        const itemsPerPage = 10;
        let currentCategory = null;
        let isSubcategory = false;
        let subCategoryName = null;

        collector.on('collect', async (buttonInteraction) => {
            if (buttonInteraction.user.id !== interaction.user.id) {
                await buttonInteraction.reply({ content: "Bu men√ºy√º sadece komutu kullanan ki≈üi kullanabilir.", ephemeral: true });
                return;
            }

            if (buttonInteraction.customId === 'home') {
                currentCategory = null;
                isSubcategory = false;
                currentPage = 0;
                await buttonInteraction.update({ 
                    embeds: [homepageEmbed], 
                    components: [homepageActionRow] 
                });
            } else if (categories[buttonInteraction.customId] && !isSubcategory) {
                currentCategory = buttonInteraction.customId;

                if (Array.isArray(categories[currentCategory])) {
                    const totalPages = Math.ceil(categories[currentCategory].length / itemsPerPage);
                    const paginatedCommands = categories[currentCategory].slice(currentPage * itemsPerPage, (currentPage + 1) * itemsPerPage);

                    const categoryEmbed = new EmbedBuilder()
                        .setTitle(currentCategory)
                        .setDescription(paginatedCommands.map(cmd => `\`${cmd.name}\`    ${cmd.description}`).join('\n') || 'Bu kategoride hen√ºz komut bulunmuyor.')
                        .setColor(Colors.Blue)
                        .setFooter({ text: `Sayfa ${currentPage + 1}/${totalPages}` })
                        .setTimestamp();

                    const previousButton = new ButtonBuilder()
                        .setCustomId('previous')
                        .setLabel('‚óÄÔ∏è')
                        .setStyle(ButtonStyle.Primary)
                        .setDisabled(currentPage === 0);

                    const nextButton = new ButtonBuilder()
                        .setCustomId('next')
                        .setLabel('‚ñ∂Ô∏è')
                        .setStyle(ButtonStyle.Primary)
                        .setDisabled(currentPage + 1 >= totalPages);

                    const backButton = new ButtonBuilder()
                        .setCustomId('home')
                        .setLabel('Ana Men√º')
                        .setEmoji('üè†')
                        .setStyle(ButtonStyle.Success);

                    const categoryActionRow = new ActionRowBuilder().addComponents(previousButton, nextButton, backButton);

                    await buttonInteraction.update({ 
                        embeds: [categoryEmbed], 
                        components: [categoryActionRow] 
                    });
                } else {
                    const subcategories = Object.keys(categories[currentCategory]);
                    const subcategoryButtons = subcategories.map(subcategory => 
                        new ButtonBuilder()
                            .setCustomId(subcategory)
                            .setLabel(subcategory)
                            .setStyle(ButtonStyle.Primary)
                            .setEmoji('üìÅ')
                    );

                    const backButton = new ButtonBuilder()
                        .setCustomId('home')
                        .setLabel('Ana Men√º')
                        .setEmoji('üè†')
                        .setStyle(ButtonStyle.Success);

                    const subcategoryActionRow = new ActionRowBuilder().addComponents(subcategoryButtons, backButton);

                    await buttonInteraction.update({ 
                        embeds: [
                            new EmbedBuilder()
                                .setTitle(`${currentCategory} Kategorileri`)
                                .setDescription('L√ºtfen bir alt kategori se√ßin:')
                                .setImage('https://media.tenor.com/_3euyl5JqWAAAAAM/naofumi-iwatani.gif')
                                .setColor(Colors.Blue)
                                .setTimestamp()
                        ], 
                        components: [subcategoryActionRow] 
                    });
                }
            } else if (currentCategory && categories[currentCategory][buttonInteraction.customId] && !isSubcategory) {
                isSubcategory = true;
                subCategoryName = buttonInteraction.customId;
                const totalPages = Math.ceil(categories[currentCategory][subCategoryName].length / itemsPerPage);
                const paginatedCommands = categories[currentCategory][subCategoryName].slice(currentPage * itemsPerPage, (currentPage + 1) * itemsPerPage);

                const subcategoryEmbed = new EmbedBuilder()
                    .setTitle(`${subCategoryName}`)
                    .setDescription(paginatedCommands.map(cmd => `\`${cmd.name}\`    ${cmd.description}`).join('\n') || 'Bu alt kategoride hen√ºz komut bulunmuyor.')
                    .setColor(Colors.Blue)
                    .setFooter({ text: `Sayfa ${currentPage + 1}/${totalPages}` })
                    .setTimestamp();

                const previousButton = new ButtonBuilder()
                    .setCustomId('previous')
                    .setLabel('‚óÄÔ∏è')
                    .setStyle(ButtonStyle.Primary)
                    .setDisabled(currentPage === 0);

                const nextButton = new ButtonBuilder()
                    .setCustomId('next')
                    .setLabel('‚ñ∂Ô∏è')
                    .setStyle(ButtonStyle.Primary)
                    .setDisabled(currentPage + 1 >= totalPages);

                const backButton = new ButtonBuilder()
                    .setCustomId('home')
                    .setLabel('Ana Men√º')
                    .setEmoji('üè†')
                    .setStyle(ButtonStyle.Success);

                const subcategoryActionRow = new ActionRowBuilder().addComponents(previousButton, nextButton, backButton);

                await buttonInteraction.update({ 
                    embeds: [subcategoryEmbed], 
                    components: [subcategoryActionRow] 
                });
            } else if (buttonInteraction.customId === 'previous') {
                currentPage--;
            } else if (buttonInteraction.customId === 'next') {
                currentPage++;
            }

            if (['previous', 'next'].includes(buttonInteraction.customId)) {
                let paginatedCommands;
                let embedTitle;

                if (isSubcategory && currentCategory && subCategoryName) {
                    paginatedCommands = categories[currentCategory][subCategoryName].slice(currentPage * itemsPerPage, (currentPage + 1) * itemsPerPage);
                    embedTitle = `${subCategoryName}`;
                } else {
                    paginatedCommands = categories[currentCategory].slice(currentPage * itemsPerPage, (currentPage + 1) * itemsPerPage);
                    embedTitle = currentCategory;
                }

                const totalPages = Math.ceil(paginatedCommands.length / itemsPerPage);

                const updatedEmbed = new EmbedBuilder()
                    .setTitle(embedTitle)
                    .setDescription(paginatedCommands.map(cmd => `\`${cmd.name}\`    ${cmd.description}`).join('\n'))
                    .setColor(Colors.Blue)
                    .setFooter({ text: `Sayfa ${currentPage + 1}/${totalPages}` })
                    .setTimestamp();

                const previousButton = new ButtonBuilder()
                    .setCustomId('previous')
                    .setLabel('‚óÄÔ∏è')
                    .setStyle(ButtonStyle.Primary)
                    .setDisabled(currentPage === 0);

                const nextButton = new ButtonBuilder()
                    .setCustomId('next')
                    .setLabel('‚ñ∂Ô∏è')
                    .setStyle(ButtonStyle.Primary)
                    .setDisabled(currentPage + 1 >= totalPages);

                const backButton = new ButtonBuilder()
                    .setCustomId('home')
                    .setLabel('Ana Men√º')
                    .setEmoji('üè†')
                    .setStyle(ButtonStyle.Success);

                const updatedActionRow = new ActionRowBuilder().addComponents(previousButton, nextButton, backButton);

                await buttonInteraction.update({ 
                    embeds: [updatedEmbed], 
                    components: [updatedActionRow] 
                });
            }
        });

        collector.on('end', async () => {
            await interaction.editReply({ 
                components: [] 
            });
        });
    }
};